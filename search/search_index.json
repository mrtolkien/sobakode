{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sobakode Stop the spaghetti code . Write soba code. TL;DR Git Trunk-based workflow with main branch Full testing coverage on PRs Releases based on commit tagging Repository Standard folders as much as possible Python poetry for environment management and packaging Google Python Style Guide Black Python Formatter Deployment Containers for everything","title":"Introduction"},{"location":"#sobakode","text":"Stop the spaghetti code . Write soba code.","title":"Sobakode"},{"location":"#tldr","text":"Git Trunk-based workflow with main branch Full testing coverage on PRs Releases based on commit tagging Repository Standard folders as much as possible Python poetry for environment management and packaging Google Python Style Guide Black Python Formatter Deployment Containers for everything","title":"TL;DR"},{"location":"1-git/1-branches/","text":"Git Branches main main should be where the most up-to-date code resides. To follow proper Continuous Integration (CI) practices, code should regularly be merged into main . Releases Releases should be created by tagging a commit. Branch names Features feat/description A feature ( feat ) is a piece of code that adds new functionality to the code. The description short but clear: feat/add-user-model feat/add-testing-ci feat/new-treemap-color-selector Fixes fix/related-issue A fix is code aimed at fixing issues in existing code. If there was a related issue opened, its ID should be added to the branch name: fix/10359-text-vertical-alignment fix/user-model-migration-rollback fix/dockerfile-source-image-update Drafts draft/description A draft branch is a Work in Progress (WiP) branch that is not made to be merged into main . It should be renamed to feat/... or fix/... once it's ready for merging. It is still a useful tool to share WiP code with coworkers! Github has supported Draft PRs for a few years now and is a great complement to that. Rationale Trunk Based Development Trunk Based Development Website Modern CI/CD pipelines should guarantee that only good code gets merged into main . This eliminates the need for a dev \"buffer\" branch that code gets merged to before reaching main. Most modern repos use this setup ( react , vscode , fastapi , ...) as well as commit-tagging for releases instead of release/xx.xx branches. Naming I have chosen to not include usernames in git branches. There should be little name collision if branches are named properly and it hurts readability.","title":"Branches"},{"location":"1-git/1-branches/#git-branches","text":"","title":"Git Branches"},{"location":"1-git/1-branches/#main","text":"main should be where the most up-to-date code resides. To follow proper Continuous Integration (CI) practices, code should regularly be merged into main .","title":"main"},{"location":"1-git/1-branches/#releases","text":"Releases should be created by tagging a commit.","title":"Releases"},{"location":"1-git/1-branches/#branch-names","text":"","title":"Branch names"},{"location":"1-git/1-branches/#features","text":"feat/description A feature ( feat ) is a piece of code that adds new functionality to the code. The description short but clear: feat/add-user-model feat/add-testing-ci feat/new-treemap-color-selector","title":"Features"},{"location":"1-git/1-branches/#fixes","text":"fix/related-issue A fix is code aimed at fixing issues in existing code. If there was a related issue opened, its ID should be added to the branch name: fix/10359-text-vertical-alignment fix/user-model-migration-rollback fix/dockerfile-source-image-update","title":"Fixes"},{"location":"1-git/1-branches/#drafts","text":"draft/description A draft branch is a Work in Progress (WiP) branch that is not made to be merged into main . It should be renamed to feat/... or fix/... once it's ready for merging. It is still a useful tool to share WiP code with coworkers! Github has supported Draft PRs for a few years now and is a great complement to that.","title":"Drafts"},{"location":"1-git/1-branches/#rationale","text":"","title":"Rationale"},{"location":"1-git/1-branches/#trunk-based-development","text":"Trunk Based Development Website Modern CI/CD pipelines should guarantee that only good code gets merged into main . This eliminates the need for a dev \"buffer\" branch that code gets merged to before reaching main. Most modern repos use this setup ( react , vscode , fastapi , ...) as well as commit-tagging for releases instead of release/xx.xx branches.","title":"Trunk Based Development"},{"location":"1-git/1-branches/#naming","text":"I have chosen to not include usernames in git branches. There should be little name collision if branches are named properly and it hurts readability.","title":"Naming"},{"location":"1-git/2-PRs/","text":"Pull Requests PR contents A good PR should include: Basic explanation of the feature/fix in the PR body New tests feat should ideally have 100% coverage of the new code fix branches should have at least one new test pertaining to what they are fixing Relevant doc Wherever that is stored (see folders ) Flow Create a PR Pass all checks Build Unit tests Integration tests Review by the relevant code owner Merge to main","title":"Pull Requests"},{"location":"1-git/2-PRs/#pull-requests","text":"","title":"Pull Requests"},{"location":"1-git/2-PRs/#pr-contents","text":"A good PR should include: Basic explanation of the feature/fix in the PR body New tests feat should ideally have 100% coverage of the new code fix branches should have at least one new test pertaining to what they are fixing Relevant doc Wherever that is stored (see folders )","title":"PR contents"},{"location":"1-git/2-PRs/#flow","text":"Create a PR Pass all checks Build Unit tests Integration tests Review by the relevant code owner Merge to main","title":"Flow"},{"location":"1-git/3-releases/","text":"Releases Continuous Deployment Continuous Deployment (CD) does not have releases by design. Ideally, main should always be representing the state of your running application. If you are developing a web app, this is likely how you should handle things and you should not make releases. Shortcomings For some development workflows, like libraries, it is necessary to make releases at a slower pace than for every single PR to main. The proper git solution for this is tags used with semantic versioning . Deployment should only be triggered when a new tag is created. Bug fixes With fixed releases, bugfixes can be necessary. Imo, the best way to fix bugs is to make a new release from the trunk. But if you really need to bugfix a specific release, the advised process from trunk based development is to: Create a late release branch Fix the bug by cherry-picking a commit from the trunk Do not commit new code directly to the branch After inactivity, the release branch is deleted from the repo","title":"Releases"},{"location":"1-git/3-releases/#releases","text":"","title":"Releases"},{"location":"1-git/3-releases/#continuous-deployment","text":"Continuous Deployment (CD) does not have releases by design. Ideally, main should always be representing the state of your running application. If you are developing a web app, this is likely how you should handle things and you should not make releases.","title":"Continuous Deployment"},{"location":"1-git/3-releases/#shortcomings","text":"For some development workflows, like libraries, it is necessary to make releases at a slower pace than for every single PR to main. The proper git solution for this is tags used with semantic versioning . Deployment should only be triggered when a new tag is created.","title":"Shortcomings"},{"location":"1-git/3-releases/#bug-fixes","text":"With fixed releases, bugfixes can be necessary. Imo, the best way to fix bugs is to make a new release from the trunk. But if you really need to bugfix a specific release, the advised process from trunk based development is to: Create a late release branch Fix the bug by cherry-picking a commit from the trunk Do not commit new code directly to the branch After inactivity, the release branch is deleted from the repo","title":"Bug fixes"},{"location":"2-tests/1-why/","text":"Why test? Easier for people to review your code Reading tests is magnitudes easier than reading code Make sure you don't break everything when you add new features AKA enabling CI/CD Iterate quickly by testing your new code as you're writing it Allows for proper debugger use Encourage functional programming as functions are easier to test The less classes the better Excuses I've heard tons of excuses as to why not to test and they're all bullshit so let's go over the main ones. It takes too long to write tests Development time is not limited by how fast you type on a keyboard. Adding tests does not take more time simply because more lines of code have been written. Writing tests saves development time by allowing for fast iteration and validation. Yes, even if you're working solo on a project, you should have tests. Specs change too rapidly Even better then, because you'll get lost without tests! Specs should be translated into tests as early as possible in the development process to make sure nothing is missed. I can't write tests for this As we often say in fighting games: Skill Issue There are test frameworks for the full stack, from backend to frontend. Learning how to use them is usually not very hard and you will quickly reap the benefits.","title":"Why"},{"location":"2-tests/1-why/#why-test","text":"Easier for people to review your code Reading tests is magnitudes easier than reading code Make sure you don't break everything when you add new features AKA enabling CI/CD Iterate quickly by testing your new code as you're writing it Allows for proper debugger use Encourage functional programming as functions are easier to test The less classes the better","title":"Why test?"},{"location":"2-tests/1-why/#excuses","text":"I've heard tons of excuses as to why not to test and they're all bullshit so let's go over the main ones.","title":"Excuses"},{"location":"2-tests/1-why/#it-takes-too-long-to-write-tests","text":"Development time is not limited by how fast you type on a keyboard. Adding tests does not take more time simply because more lines of code have been written. Writing tests saves development time by allowing for fast iteration and validation. Yes, even if you're working solo on a project, you should have tests.","title":"It takes too long to write tests"},{"location":"2-tests/1-why/#specs-change-too-rapidly","text":"Even better then, because you'll get lost without tests! Specs should be translated into tests as early as possible in the development process to make sure nothing is missed.","title":"Specs change too rapidly"},{"location":"2-tests/1-why/#i-cant-write-tests-for-this","text":"As we often say in fighting games: Skill Issue There are test frameworks for the full stack, from backend to frontend. Learning how to use them is usually not very hard and you will quickly reap the benefits.","title":"I can't write tests for this"},{"location":"4-python/environment/","text":"","title":"Environment"},{"location":"4-python/packaging/","text":"","title":"Packaging"}]}